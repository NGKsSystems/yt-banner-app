<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>YT Banner Editor</title>
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Rajdhani', sans-serif;
      background-color: #1e1e1e;
      color: #fff;
      margin: 0;
      padding: 0;
      text-align: center;
    }

    header {
      background: #222;
      padding: 10px;
      font-size: 24px;
      font-weight: 600;
    }

    .step {
      display: none;
      margin: 20px;
      animation: fadein 0.5s ease;
    }

    .step.active {
      display: block;
    }

    @keyframes fadein {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    canvas {
      width: 100%;
      max-width: 100%;
      height: auto;
      background: #000;
      margin: 20px auto;
      display: block;
      border: 2px solid yellow;
    }

    .controls {
      margin: 10px;
    }

    button, input[type="file"] {
      padding: 10px 15px;
      font-size: 18px;
      margin: 5px;
    }

    .progress {
      display: flex;
      justify-content: center;
      margin: 10px 0;
    }

    .progress div {
      width: 100px;
      height: 10px;
      margin: 0 5px;
      background: gray;
    }

    .progress .active {
      background: limegreen;
    }

    .mode-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
    }
  </style>
</head>
<body>
  <header>
    YT Banner Editor
    <button class="mode-toggle" onclick="toggleMode()">ðŸŒ“</button>
  </header>

  <div class="progress">
    <div id="p1" class="active"></div>
    <div id="p2"></div>
    <div id="p3"></div>
  </div>

  <div id="step1" class="step active">
    <h2>Step 1: Add Background</h2>
    <input type="file" onchange="addBackground(event)" />
  </div>

  <div id="step2" class="step">
    <h2>Step 2: Add Overlay Images</h2>
    <input type="file" multiple onchange="addOverlay(event)" />
  </div>

  <div id="step3" class="step">
    <h2>Step 3: Export</h2>
    <button onclick="exportCanvas()">Export</button>
  </div>

  <canvas id="canvas" width="2560" height="1440"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let images = [];
    let selected = null;
    let dragging = false;
    let resizing = null;
    let selectedHandle = -1;
    let showHandles = true;

    const handles = [
      [-1, -1], [0, -1], [1, -1],
      [-1,  0],          [1,  0],
      [-1,  1], [0,  1], [1,  1]
    ];

    const stepEls = [
      document.getElementById('step1'),
      document.getElementById('step2'),
      document.getElementById('step3')
    ];

    function nextStep() {
      for (let i = 0; i < stepEls.length; i++) {
        if (stepEls[i].classList.contains('active')) {
          stepEls[i].classList.remove('active');
          document.getElementById('p' + (i + 1)).classList.remove('active');
          if (i + 1 < stepEls.length) {
            stepEls[i + 1].classList.add('active');
            document.getElementById('p' + (i + 2)).classList.add('active');
          }
          break;
        }
      }
    }

    function addBackground(e) {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        images = [{ img, x: 0, y: 0, width: canvas.width, height: canvas.height, mobileSafe: false }];
        drawCanvas();
        nextStep();
      };
      img.src = URL.createObjectURL(file);
    }

    function addOverlay(e) {
      [...e.target.files].forEach(file => {
        const img = new Image();
        img.onload = () => {
          images.push({ img, x: 800, y: 400, width: 400, height: 400, mobileSafe: true, selected: false });
          drawCanvas();
        };
        img.src = URL.createObjectURL(file);
      });
      nextStep();
    }

    function drawHandles(o) {
      const size = 10;
      handles.forEach(([dx, dy]) => {
        const cx = o.x + (dx + 1) * o.width / 2;
        const cy = o.y + (dy + 1) * o.height / 2;
        ctx.fillStyle = "white";
        ctx.fillRect(cx - size/2, cy - size/2, size, size);
      });
    }

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      images.forEach(o => {
        ctx.drawImage(o.img, o.x, o.y, o.width, o.height);
        if (showHandles && o.selected) {
          ctx.strokeStyle = o.mobileSafe ? "lime" : "red";
          ctx.strokeRect(o.x, o.y, o.width, o.height);
          drawHandles(o);
        }
      });
    }

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      selected = null;
      resizing = null;

      for (let i = images.length - 1; i >= 0; i--) {
        const o = images[i];
        const hIndex = hitTestHandle(o, mx, my);
        if (hIndex !== -1) {
          resizing = o;
          selectedHandle = hIndex;
          o.selected = true;
          drawCanvas();
          return;
        } else if (mx >= o.x && mx <= o.x + o.width && my >= o.y && my <= o.y + o.height) {
          selected = o;
          o.selected = true;
          dragging = true;
          drawCanvas();
          return;
        }
      }

      images.forEach(o => o.selected = false);
      drawCanvas();
    });

    canvas.addEventListener('mousemove', e => {
      if (!dragging && !resizing) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (dragging && selected) {
        selected.x += e.movementX;
        selected.y += e.movementY;
      } else if (resizing) {
        resizeByHandle(resizing, selectedHandle, mx, my);
      }
      drawCanvas();
    });

    canvas.addEventListener('mouseup', () => {
      dragging = false;
      resizing = null;
    });

    window.addEventListener('keydown', e => {
      if (!selected) return;
      switch (e.key) {
        case 'ArrowUp': selected.y -= 1; break;
        case 'ArrowDown': selected.y += 1; break;
        case 'ArrowLeft': selected.x -= 1; break;
        case 'ArrowRight': selected.x += 1; break;
      }
      drawCanvas();
    });

    function hitTestHandle(o, mx, my) {
      const size = 10;
      for (let i = 0; i < handles.length; i++) {
        const [dx, dy] = handles[i];
        const cx = o.x + (dx + 1) * o.width / 2;
        const cy = o.y + (dy + 1) * o.height / 2;
        if (mx >= cx - size/2 && mx <= cx + size/2 &&
            my >= cy - size/2 && my <= cy + size/2) {
          return i;
        }
      }
      return -1;
    }

    function resizeByHandle(o, hIndex, mx, my) {
      const prev = { ...o };
      const dx = mx - o.x;
      const dy = my - o.y;

      switch (hIndex) {
        case 0: o.width += o.x - mx; o.height += o.y - my; o.x = mx; o.y = my; break;
        case 1: o.height += o.y - my; o.y = my; break;
        case 2: o.width = mx - o.x; o.height += o.y - my; o.y = my; break;
        case 3: o.width += o.x - mx; o.x = mx; break;
        case 4: o.width = mx - o.x; break;
        case 5: o.width += o.x - mx; o.height = my - o.y; o.x = mx; break;
        case 6: o.height = my - o.y; break;
        case 7: o.width = mx - o.x; o.height = my - o.y; break;
      }

      if (o.width < 10 || o.height < 10) Object.assign(o, prev);
    }

    function exportCanvas() {
      showHandles = false;
      drawCanvas();
      const link = document.createElement('a');
      link.download = 'yt_banner_final.png';
      link.href = canvas.toDataURL();
      link.click();
      showHandles = true;
      drawCanvas();
    }

    function toggleMode() {
      const dark = document.body.style.backgroundColor === 'rgb(30, 30, 30)';
      document.body.style.backgroundColor = dark ? '#fff' : '#1e1e1e';
      document.body.style.color = dark ? '#000' : '#fff';
    }
  </script>
</body>
</html>
