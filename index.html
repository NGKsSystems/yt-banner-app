<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YouTube Banner Editor</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    canvas {
      border: 2px solid yellow;
      display: block;
      margin: 20px auto;
      background-color: #222;
    }
    input, button {
      margin: 8px;
    }
  </style>
</head>
<body>
  <h2>NGKs Banner Editor</h2>
  <input type="file" id="imageInput" accept="image/*" multiple />
  <button id="clearBtn">Clear Canvas</button>
  <button id="deleteBtn">Delete Selected</button>
  <button id="exportBtn">Export Banner</button>
  <canvas id="canvas" width="2560" height="1440"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const imageInput = document.getElementById("imageInput");
    const exportBtn = document.getElementById("exportBtn");
    const deleteBtn = document.getElementById("deleteBtn");
    const clearBtn = document.getElementById("clearBtn");

    let images = [];
    let selectedIndex = null;
    let dragging = false;
    let dragOffsetX, dragOffsetY;
    let resizing = false;
    let activeHandle = null;

    const HANDLE_SIZE = 10;

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw all images
      images.forEach((img, i) => {
        ctx.drawImage(img.img, img.x, img.y, img.width, img.height);

        // If selected, draw resize handles
        if (i === selectedIndex) {
          drawResizeHandles(img);
        }
      });

      // Draw mobile safe zone overlay
      ctx.strokeStyle = "lime";
      ctx.lineWidth = 2;
      ctx.strokeRect(507, 509, 1546, 423);
    }

    function drawResizeHandles(img) {
      ctx.fillStyle = "white";
      const points = getHandlePoints(img);
      points.forEach(p => ctx.fillRect(p.x - HANDLE_SIZE/2, p.y - HANDLE_SIZE/2, HANDLE_SIZE, HANDLE_SIZE));
    }

    function getHandlePoints(img) {
      const {x, y, width, height} = img;
      return [
        {x, y}, // top-left
        {x: x + width / 2, y}, // top-center
        {x: x + width, y}, // top-right
        {x, y: y + height / 2}, // mid-left
        {x: x + width, y: y + height / 2}, // mid-right
        {x, y: y + height}, // bottom-left
        {x: x + width / 2, y: y + height}, // bottom-center
        {x: x + width, y: y + height} // bottom-right
      ];
    }

    function getHandleUnderMouse(mx, my, img) {
      const points = getHandlePoints(img);
      return points.findIndex(p =>
        mx >= p.x - HANDLE_SIZE &&
        mx <= p.x + HANDLE_SIZE &&
        my >= p.y - HANDLE_SIZE &&
        my <= p.y + HANDLE_SIZE
      );
    }

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      for (let i = images.length - 1; i >= 1; i--) {
        const img = images[i];
        const handleIndex = getHandleUnderMouse(mx, my, img);
        if (handleIndex !== -1) {
          selectedIndex = i;
          resizing = true;
          activeHandle = handleIndex;
          return;
        }

        if (mx >= img.x && mx <= img.x + img.width && my >= img.y && my <= img.y + img.height) {
          selectedIndex = i;
          dragging = true;
          dragOffsetX = mx - img.x;
          dragOffsetY = my - img.y;
          drawCanvas();
          return;
        }
      }

      selectedIndex = null;
      drawCanvas();
    });

    canvas.addEventListener("mousemove", e => {
      if (resizing && selectedIndex !== null) {
        const img = images[selectedIndex];
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        let deltaX = mx - img.x;
        let deltaY = my - img.y;

        switch (activeHandle) {
          case 0: // top-left
            img.width += img.x - mx;
            img.height += img.y - my;
            img.x = mx;
            img.y = my;
            break;
          case 1: // top-center
            img.height += img.y - my;
            img.y = my;
            break;
          case 2: // top-right
            img.width = mx - img.x;
            img.height += img.y - my;
            img.y = my;
            break;
          case 3: // mid-left
            img.width += img.x - mx;
            img.x = mx;
            break;
          case 4: // mid-right
            img.width = mx - img.x;
            break;
          case 5: // bottom-left
            img.width += img.x - mx;
            img.height = my - img.y;
            img.x = mx;
            break;
          case 6: // bottom-center
            img.height = my - img.y;
            break;
          case 7: // bottom-right
            img.width = mx - img.x;
            img.height = my - img.y;
            break;
        }

        drawCanvas();
      }

      if (dragging && selectedIndex !== null) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const img = images[selectedIndex];
        img.x = mx - dragOffsetX;
        img.y = my - dragOffsetY;
        drawCanvas();
      }
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
      resizing = false;
      activeHandle = null;
    });

    imageInput.addEventListener("change", e => {
      const files = Array.from(e.target.files);
      files.forEach((file, i) => {
        const reader = new FileReader();
        reader.onload = function(evt) {
          const img = new Image();
          img.onload = () => {
            let imgObj;
            if (images.length === 0) {
              // Background image
              imgObj = { img, x: 0, y: 0, width: canvas.width, height: canvas.height };
            } else if (images.length === 1) {
              // Mobile safe image
              imgObj = { img, x: 740, y: 620, width: 1080, height: 200 };
            } else {
              // User placed overlay
              imgObj = { img, x: 100, y: 100, width: 300, height: 100 };
            }
            images.push(imgObj);
            drawCanvas();
          };
          img.src = evt.target.result;
        };
        reader.readAsDataURL(file);
      });
    });

    exportBtn.addEventListener("click", () => {
      const temp = selectedIndex;
      selectedIndex = null;
      drawCanvas();
      const link = document.createElement("a");
      link.download = "yt_banner_final.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
      selectedIndex = temp;
      drawCanvas();
    });

    deleteBtn.addEventListener("click", () => {
      if (selectedIndex && selectedIndex > 0) {
        images.splice(selectedIndex, 1);
        selectedIndex = null;
        drawCanvas();
      }
    });

    clearBtn.addEventListener("click", () => {
      images = [];
      selectedIndex = null;
      drawCanvas();
    });

    document.addEventListener("keydown", e => {
      if (selectedIndex && images[selectedIndex]) {
        const img = images[selectedIndex];
        switch (e.key) {
          case "ArrowUp":
            img.y -= 5;
            break;
          case "ArrowDown":
            img.y += 5;
            break;
          case "ArrowLeft":
            img.x -= 5;
            break;
          case "ArrowRight":
            img.x += 5;
            break;
        }
        drawCanvas();
      }
    });
  </script>
</body>
</html>
