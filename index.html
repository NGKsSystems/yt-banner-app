
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NGKs Banner Editor</title>
  <style>
    body { background: #111; color: white; text-align: center; font-family: Arial; }
    canvas { border: 2px solid yellow; background: #000; margin-top: 10px; }
    .hidden { display: none; }
  .control-panel {
  background: #222;
  border: 2px solid #555;
  border-radius: 10px;
  padding: 20px;
  margin: 0 auto;
  width: fit-content;
  text-align: left;
  box-shadow: 0 0 10px rgba(255,255,255,0.1);
}
button, input[type="file"] {
  margin: 5px;
  padding: 8px 12px;
  background: #444;
  border: 1px solid #888;
  color: white;
  border-radius: 5px;
  cursor: pointer;
}
button:hover {
  background: #666;
}
body {
  background: #111;
  color: #eee;
  text-align: center;
  font-family: 'Segoe UI', Tahoma, sans-serif;
  font-size: 16px;
}
h3 {
  font-size: 1.8rem;
  color: #00ccff;
  margin-bottom: 10px;
}
</style>
</head>
<body>
  
<h3>NGKs Banner Editor</h3>
<div class="control-panel">
  <div id="step1">
    Step 1: Choose your background 
    <input type="file" id="bgInput" accept="image/*" />
    <button id="skipBg">Skip</button>
  </div>

  <div id="step2" class="hidden">
    Step 2: Choose your mobile-safe image
    <input type="file" id="mobileInput" accept="image/*" />
  </div>

  <div id="step3" class="hidden">
    Step 3: Add additional images
    <input type="file" id="extraInput" accept="image/*" />
  </div>

  <button onclick="resetCanvas()">Clear All</button>
  
  <div id="exportSection" class="hidden">
    <button id="exportBtn">Export Banner</button>
  </div>

  </div>

  <canvas id="bannerCanvas" width="2560" height="1440"></canvas>

  <script>
    const canvas = document.getElementById("bannerCanvas");
    const ctx = canvas.getContext("2d");
    const overlays = [];
    const handleSize = 10;
    let dragging = null, resizing = null, selectedHandle = null;
    let dragOffsetX = 0, dragOffsetY = 0;
let exporting = false;

    const bgInput = document.getElementById("bgInput");
    const skipBg = document.getElementById("skipBg");
    const mobileInput = document.getElementById("mobileInput");
    const extraInput = document.getElementById("extraInput");
    const exportBtn = document.getElementById("exportBtn");

    function drawHandles(obj) {
      const x = obj.x, y = obj.y, w = obj.width, h = obj.height;
      const points = [
        [x, y], [x + w/2, y], [x + w, y],
        [x + w, y + h/2], [x + w, y + h],
        [x + w/2, y + h], [x, y + h],
        [x, y + h/2]
      ];
      ctx.fillStyle = "white";
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      points.forEach(([px, py]) => {
        ctx.fillRect(px - handleSize/2, py - handleSize/2, handleSize, handleSize);
        ctx.strokeRect(px - handleSize/2, py - handleSize/2, handleSize, handleSize);
        ctx.fillRect(px - handleSize/2, py - handleSize/2, handleSize, handleSize);
      });
    }

    function drawCanvas(showHandles = true) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const bg = overlays.find(o => o.bg);
      if (bg) ctx.drawImage(bg.img, 0, 0, canvas.width, canvas.height);
// Draw static yellow mobile-safe zone overlay (YouTube spec)
  if (!exporting) {
  ctx.strokeStyle = "yellow";
  ctx.lineWidth = 2;
  ctx.strokeRect(507, 509, 1546, 423);
}

      overlays.forEach(o => {
        if (!o.bg) ctx.drawImage(o.img, o.x, o.y, o.width, o.height);
        if (o.selected) {
        if (showHandles && o.selected) {
  ctx.strokeStyle = o.mobileSafe ? "lime" : "red";
  ctx.strokeRect(o.x, o.y, o.width, o.height);
}
      }
        if (showHandles && o.selected) drawHandles(o);
      });
    }

    function hitTestHandle(obj, mx, my) {
      const x = obj.x, y = obj.y, w = obj.width, h = obj.height;
      const positions = [
        [x, y], [x + w/2, y], [x + w, y],
        [x + w, y + h/2], [x + w, y + h],
        [x + w/2, y + h], [x, y + h],
        [x, y + h/2]
      ];
      for (let i = 0; i < positions.length; i++) {
        const [px, py] = positions[i];
        if (mx >= px - handleSize && mx <= px + handleSize &&
            my >= py - handleSize && my <= py + handleSize) {
          return i;
        }
      }
      return -1;
    }

    function resizeByHandle(obj, handleIndex, mx, my) {
      const x = obj.x, y = obj.y, w = obj.width, h = obj.height;
      switch (handleIndex) {
        case 0: obj.width += obj.x - mx; obj.height += obj.y - my; obj.x = mx; obj.y = my; break;
        case 1: obj.height += obj.y - my; obj.y = my; break;
        case 2: obj.width = mx - obj.x; obj.height += obj.y - my; obj.y = my; break;
        case 3: obj.width = mx - obj.x; break;
        case 4: obj.width = mx - obj.x; obj.height = my - obj.y; break;
        case 5: obj.height = my - obj.y; break;
        case 6: obj.width += obj.x - mx; obj.height = my - obj.y; obj.x = mx; break;
        case 7: obj.width += obj.x - mx; obj.x = mx; break;
      }
    }

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;

      for (let i = overlays.length - 1; i >= 0; i--) {
        const o = overlays[i];
        if (o.bg) continue;
        o.selected = false;
        const hIndex = hitTestHandle(o, mx, my);
        if (hIndex !== -1) {
          resizing = o;
          selectedHandle = hIndex;
          o.selected = true;
          drawCanvas();
let hovering = false;
      for (let i = overlays.length - 1; i >= 0; i--) {
        const o = overlays[i];
        if (o.bg) continue;
        const hIndex = hitTestHandle(o, mx, my);
        if (hIndex !== -1) {
          canvas.style.cursor = "nwse-resize";
          hovering = true;
          break;
        } else if (mx >= o.x && mx <= o.x + o.width && my >= o.y && my <= o.y + o.height) {
          canvas.style.cursor = "move";
          hovering = true;
          break;
        }
      }
      if (!hovering) canvas.style.cursor = "default";
          return;
        }
        if (mx >= o.x && mx <= o.x + o.width && my >= o.y && my <= o.y + o.height) {
          dragging = o;
          dragOffsetX = mx - o.x;
          dragOffsetY = my - o.y;
          o.selected = true;
          drawCanvas();
          return;
        }
      }
    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;

      if (dragging) {
        dragging.x = mx - dragOffsetX;
        dragging.y = my - dragOffsetY;
        drawCanvas();
      } else if (resizing) {
        resizeByHandle(resizing, selectedHandle, mx, my);
        drawCanvas();
      }
    });

    canvas.addEventListener("mouseup", () => {
      dragging = null;
      resizing = null;
      selectedHandle = null;
    });

    bgInput.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    overlays.push({ img, bg: true });
    drawCanvas();
    document.getElementById("step1").classList.add("hidden");
    document.getElementById("step2").classList.remove("hidden");
  };
  img.src = URL.createObjectURL(file);
});

skipBg.addEventListener("click", () => {
  drawCanvas();
  document.getElementById("step1").classList.add("hidden");
  document.getElementById("step2").classList.remove("hidden");
});

mobileInput.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    overlays.push({
      img,
      x: 507,
      y: 509,
      width: 1546,
      height: 423,
      mobileSafe: true
    });
    drawCanvas();
    document.getElementById("step2").classList.add("hidden");
    document.getElementById("step3").classList.remove("hidden");
    document.getElementById("exportSection").classList.remove("hidden");
  };
  img.src = URL.createObjectURL(file);
});
      img.src = URL.createObjectURL(file);
    });

    extraInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        overlays.push({
          img,
          x: 100,
          y: 100,
          width: 300,
          height: 100
        });
        drawCanvas();
      };
      img.src = URL.createObjectURL(file);
    });

    function resetCanvas() {
      overlays.length = 0;
      drawCanvas();
    }

    exportBtn.addEventListener("click", () => {
      overlays.forEach(o => o.selected = false);
      exporting = true;
      drawCanvas(false);
      const link = document.createElement("a");
      link.download = `yt_banner_${Date.now()}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
      exporting = false;
      drawCanvas(true);
    });
  
document.addEventListener("keydown", (e) => {
  const selected = overlays.find(o => o.selected);
  if (!selected) return;

  const moveStep = e.shiftKey ? 10 : 1;

  switch (e.key) {
    case "ArrowUp":
      selected.y -= moveStep;
      break;
    case "ArrowDown":
      selected.y += moveStep;
      break;
    case "ArrowLeft":
      selected.x -= moveStep;
      break;
    case "ArrowRight":
      selected.x += moveStep;
      break;
    default:
      return;
  }

  drawCanvas();
});

</script>
</body>
</html>
