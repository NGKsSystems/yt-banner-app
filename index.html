<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YouTube Banner Editor</title>
  <style>
    body {
      background: #111;
      color: #fff;
      text-align: center;
      font-family: sans-serif;
    }
    canvas {
      border: 2px solid yellow;
      margin: 20px auto;
      display: block;
      cursor: crosshair;
    }
    input {
      margin: 10px;
    }
  </style>
</head>
<body>
  <h2>NGKs Banner Editor</h2>

  <!-- Step 1 -->
  <div>
    <label>Choose Background or Skip:</label>
    <input type="file" id="bgInput" accept="image/*">
    <button onclick="nextStep()">Skip</button>
  </div>

  <!-- Step 2 -->
  <div id="mobileZoneInput" style="display:none;">
    <label>Choose Your Mobile Safe Image:</label>
    <input type="file" id="mobileInput" accept="image/*">
  </div>

  <!-- Step 3 -->
  <div id="extraInput" style="display:none;">
    <label>Add Extra Images (optional):</label>
    <input type="file" id="extraInputFile" accept="image/*" multiple>
  </div>

  <canvas id="bannerCanvas" width="2560" height="1440"></canvas>
  <br>
  <button onclick="exportImage()">Export Image</button>

  <script>
    const canvas = document.getElementById("bannerCanvas");
    const ctx = canvas.getContext("2d");

    let objects = []; // All images except background
    let background = null;
    let selected = null;
    let dragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (background) ctx.drawImage(background.img, 0, 0, canvas.width, canvas.height);
      objects.forEach(obj => {
        ctx.drawImage(obj.img, obj.x, obj.y, obj.w, obj.h);
        if (obj === selected) drawHandles(obj);
      });

      // Mobile safe zone overlay
      ctx.strokeStyle = "lime";
      ctx.lineWidth = 2;
      ctx.strokeRect(740, 620, 1080, 200);
    }

    function drawHandles(obj) {
      ctx.fillStyle = "white";
      const size = 10;
      const points = [
        [obj.x, obj.y],
        [obj.x + obj.w / 2, obj.y],
        [obj.x + obj.w, obj.y],
        [obj.x + obj.w, obj.y + obj.h / 2],
        [obj.x + obj.w, obj.y + obj.h],
        [obj.x + obj.w / 2, obj.y + obj.h],
        [obj.x, obj.y + obj.h],
        [obj.x, obj.y + obj.h / 2]
      ];
      points.forEach(([x, y]) => ctx.fillRect(x - size / 2, y - size / 2, size, size));
    }

    // Step 1
    document.getElementById("bgInput").addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        background = { img };
        drawCanvas();
        document.getElementById("mobileZoneInput").style.display = "block";
      };
      img.src = URL.createObjectURL(file);
    });

    function nextStep() {
      document.getElementById("mobileZoneInput").style.display = "block";
    }

    // Step 2
    document.getElementById("mobileInput").addEventListener("change", e => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        const obj = {
          img,
          x: 740,
          y: 620,
          w: 1080,
          h: 200
        };
        objects.push(obj);
        selected = obj;
        drawCanvas();
        document.getElementById("extraInput").style.display = "block";
      };
      img.src = URL.createObjectURL(file);
    });

    // Step 3
    document.getElementById("extraInputFile").addEventListener("change", e => {
      const files = [...e.target.files];
      files.forEach(file => {
        const img = new Image();
        img.onload = () => {
          const obj = {
            img,
            x: 100,
            y: 100,
            w: img.width / 2,
            h: img.height / 2
          };
          objects.push(obj);
          selected = obj;
          drawCanvas();
        };
        img.src = URL.createObjectURL(file);
      });
    });

    // Mouse handling
    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      selected = null;

      for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (mx >= obj.x && mx <= obj.x + obj.w && my >= obj.y && my <= obj.y + obj.h) {
          selected = obj;
          dragOffsetX = mx - obj.x;
          dragOffsetY = my - obj.y;
          dragging = true;
          break;
        }
      }
      drawCanvas();
    });

    canvas.addEventListener("mousemove", e => {
      if (!dragging || !selected) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      selected.x = mx - dragOffsetX;
      selected.y = my - dragOffsetY;
      drawCanvas();
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
    });

    // Arrow key + delete
    document.addEventListener("keydown", e => {
      if (!selected) return;
      const moveAmount = e.shiftKey ? 10 : 1;
      switch (e.key) {
        case "ArrowUp":
          selected.y -= moveAmount;
          break;
        case "ArrowDown":
          selected.y += moveAmount;
          break;
        case "ArrowLeft":
          selected.x -= moveAmount;
          break;
        case "ArrowRight":
          selected.x += moveAmount;
          break;
        case "Delete":
          const i = objects.indexOf(selected);
          if (i !== -1) {
            objects.splice(i, 1);
            selected = null;
          }
          break;
      }
      drawCanvas();
    });

    function exportImage() {
      // Hide handles for export
      const wasSelected = selected;
      selected = null;
      drawCanvas();
      const link = document.createElement("a");
      link.download = "yt_banner_final.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
      selected = wasSelected;
      drawCanvas();
    }
  </script>
</body>
</html>
